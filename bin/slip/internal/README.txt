package slip.internal; 

Short summary in logical order
------------------------------
public abstract class AbstractNode               // super class of everything in this package

  public class Prog extends AbstractNode         // Program (set of methods) : {method, ..., method}

  public abstract class Stmt extends AbstractNode// any statement with labels including method declarations
    public class Method   extends Stmt           // name(x,...,x) ld {stmts} lf x (method declaration)
    public class CmdStmt  extends Stmt           // l cmd l (unconditional statement)
    public class CondStmt extends Stmt           // l if cond then l else l (conditional statement)
      public class Cond      extends AbstractNode// sexpr cop sexpr
        public abstract class Cop extends AbstractNode// cop
          public class  Equal extends Cop               // "=="
          public class  Less  extends Cop               // <

  public abstract class Cmd  extends AbstractNode// any command (without labels)
    public abstract class Ass extends Cmd          // any kind of assignment
      public class NormalAss     extends Ass         // des = expr
      public class NewAss        extends Ass         // x = new/i ;
      public abstract class Call extends Ass         // method call 
        public class SimpleCall   extends Call         // x = m(x, ..., x);
        public class SuperCall    extends Call         // x = super.m(x,..., x)
        public class VariableCall extends Call         // x = x.m(x,..., x)
    public class   In         extends Cmd          // read(x)
    public class   Out        extends Cmd          // write(x)
    public class   Skip       extends Cmd          // skip

  public abstract class Expr extends AbstractNode// expr  ::= cexpr | sexpr
    public class Cexpr extends Expr                // cexpr ::= sexpr aop sexpr
      public abstract class Aop extends AbstractNode // aop (arithmetic operator)
        public class Divide    extends Aop              // "/"
        public class Minus     extends Aop              // -
        public class Plus      extends Aop              // +
        public class Remainder extends Aop              // %
        public class Times     extends Aop              // *
    public abstract class Sexpr extends Expr            // sexpr ::= des | i | null | this
      public abstract class Des extends Sexpr        // des ::= x | x . i | this . i
        public class VarDes         extends Des         // x 
        public class FieldDes       extends Des         // x . i (i-th field of an object)
        public class ThisFieldDes   extends Des         // this.i
      public class I               extends Sexpr        // i (>=0)
      public class Null            extends Sexpr     // null
      public class This            extends Sexpr      // this 

Description of relevant fields and constructors
-----------------------------------------------
Preliminary notes : 

- There are no (explicit) classes to represent variable names and labels
  for the following reasons :
  = Every local variable is represented by a natural number ranging from
    0 to the total number of variables used (referred to) in the method.
  = Each statement (stmt) is represented by a (Java) object. 
    We use the Java reference to this object as the start label of the statement.
  = Very importantly, the final label (lf) of a method is represented
    by the Java reference to the object representing the method declaration.
  = To summarize : the references to the statements *are* their labels. 

public abstract class AbstractNode               // super class of everything in this package

  public class Prog extends AbstractNode         // Program (set of methods) : {method, ..., method}
  { Method[] meths; // Declaration of all methods, not sorted in any particular order
    public Prog(Method[] meths) // constructor }

  public abstract class Stmt extends AbstractNode// any statement with labels including method declarations

    public class Method   extends Stmt          
    // Method declaration : name(x,...,x) ld {stmts} lf xr
    { public String  m ; // Method identifier 			
      boolean isStatic ; // true --> static ; false --> non static			
      public int level ; // level >= 0 (if non static) : name ::= m/level
      public int arity ; // Number of formal parameters (x_1, ..., x_arity) (method arity)
      Stmt   l   ; // label of the first instruction (ld)
      int    nlv ; // Number of local variables (in source code)
      int    nav ; // Number of auxiliary variables (generated by the translation process)
      int    r   ; // result variable (xr) 0 <= r <= nlv + nav
      // final label (lf) : this
      String[]  var ; // the names of all local variables var[i] = i+1 th variable name

      public Method(String m, String[] var, boolean isStatic, int level, int arity, int nlv, int r)
      public void setPar(Stmt l, int nav)
    }


    public class CmdStmt  extends Stmt           
    // ld cmd lf (unconditional statement)
    { // ld == this
      Cmd  cmd;
      Stmt next; // lf

      public CmdStmt(Cmd cmd, Stmt lf)
      public void setLabel(Stmt lf) 
    }

    public class CondStmt extends Stmt           
    // ld if cond then lt else lf (conditional statement)
    public class CondStmt extends Stmt 
    { // ld == this
      Cond cond;
      Stmt ltrue;  // lt final label if true
      Stmt lfalse; // lf final label if false

      public CondStmt(Cond cond)
      public void setTrueLabel(Stmt lt) 
      public void setFalseLabel(Stmt lf)
      public CondStmt(Cond cond, Stmt lt, Stmt lf)
    }


      public class Cond      extends AbstractNode// sexpr cop sexpr
      { Sexpr expr1;
        Cop  cop;
        Sexpr expr2;
      }

        public abstract class Cop extends AbstractNode// cop
          public class  Equal extends Cop               // "=="
          public class  Less  extends Cop               // <

  public abstract class Cmd  extends AbstractNode// any command (without labels)

    public abstract class Ass extends Cmd          // any kind of assignment

      public class NormalAss     extends Ass         
      // des = expr
      { Des left ; // des
        Expr right ; // expr
      }

      public class NewAss        extends Ass         
      // x = new/i ;
      { int x ; // where to put the reference to the object
        int i ; // level of the object to be created
      }

      public abstract class Call extends Ass         
      // method call : x = ...(x_0, ..., x_n-1)
      { int x;    // x
        int[] ap; // x_0, ..., x_n-1
      }
        public class SimpleCall   extends Call         
        // ... = m(...);
        { String m;   // Name of the method }

        public class SuperCall    extends Call         
        // ... = super.m(...);
        { String m;   // Name of the method }

        public class VariableCall extends Call         
        // ... = x.m(...);
        { int target; // x : target of the call 
          String m;   // Name of the method
        }

    public class   In         extends Cmd          
    // read(x)
    { int x; }

    public class   Out        extends Cmd          
    // write(x)
    { int x; }

    public class   Skip       extends Cmd          
    // skip

  public abstract class Expr extends AbstractNode
  // expr  ::= cexpr | sexpr
  
    public class Cexpr extends Expr                
    // cexpr ::= sexpr1 aop sexpr2
    { Sexpr expr1; 
      Aop  aop;
      Sexpr expr2; 
    }
      public abstract class Aop extends AbstractNode // aop (arithmetic operator)
        public class Divide    extends Aop              // "/"
        public class Minus     extends Aop              // -
        public class Plus      extends Aop              // +
        public class Remainder extends Aop              // %
        public class Times     extends Aop              // *

    public abstract class Sexpr extends Expr         // sexpr ::= des | i | null | this
      public abstract class Des extends Sexpr        // des ::= x | x . i | this . i
      { int x; // the variable index (x) or 0 (this)
        int i; // the field number (x.i | this.i)	or 0 (x)
      }		
        public class VarDes         extends Des         // x 
        public class FieldDes       extends Des         // x . i (i-th field of an object)
        public class ThisFieldDes   extends Des         // this.i

      public class I               extends Sexpr        
      // i (>=0)
      { int i; // this integral value }
      public class Null            extends Sexpr     // null
      public class This            extends Sexpr      // this 



Short summary (alphabetical order)
----------------------------------
public abstract class AbstractNode               // super class of everything in this package
  public abstract class Aop extends AbstractNode // arithmetic operator
    public abstract class Ass extends Cmd        // any kind of assignment
      public abstract class Call extends Ass     // method call 
    public class Cexpr extends Expr              // cexpr
  public abstract class Cmd extends AbstractNode // any command (without labels)
    public class CmdStmt extends Stmt            // l cmd l (unconditional statement)
  public class Cond extends AbstractNode         // sexpr cop sexpr
    public class CondStmt extends Stmt           // l if cond then l else l (conditional statement)
  public abstract class Cop extends AbstractNode // cop
      public abstract class Des extends Sexpr    // des
    public class Divide extends Aop              // "/"
    public class  Equal extends Cop              // "=="
  public abstract class Expr extends AbstractNode// expr
    public class FieldDes extends Des            // x . i (i-th field of an object)
      public class I extends Sexpr               // i (>=0)
    public class In extends Cmd                  // read(x)
    public class  Less extends Cop               // <
    public class Method extends Stmt             // name(x,...,x) ld {stmts} lf x (method declaration)
    public class Minus extends Aop               // -
      public class NewAss extends Ass            // x = new/i ;
      public class NormalAss extends Ass         // des = expr
    public class Null extends Sexpr              // null
    public class Out extends Cmd                 // write(x)
    public class Plus extends Aop                // +
  public class Prog extends AbstractNode         // Program (set of methods)
    public class Remainder extends Aop           // %
    public abstract class Sexpr extends Expr     // sexpr 
    public class SimpleCall extends Call         // x = m(x, ..., x);
    public class Skip extends Cmd                // skip
  public abstract class Stmt extends AbstractNode// any statement with labels including method declarations
        public class SuperCall extends Call      // x = super.m(x,..., x)
    public class This extends Sexpr              // this (as a right expression)
        public class ThisFieldDes extends Des    // this.i
    public class Times extends Aop               // *
        public class VarDes extends Des          // x 
        public class VariableCall extends Call   // x = super.m(x,..., x)













